{
    "docs": [
        {
            "location": "/",
            "text": "About Donkey\n\n\nDonkey is a high level self driving library written in Python and capable of \ncontrolling ackerman or differential drive vehicles. It was developed with a \nfocus on enabling fast experimentation and easy contribution.\n\n\n\n\nBuild your own Donkey2\n\n\nDonkey2 is the standard car that most people start with. The parts cost $200\nand take 2 hours to assemple. Here are the main steps to build your own car: \n\n\n\n\nBuild a car.\n.\n\n\nInstall the software.\n\n\nCalibrate your car.\n\n\nStart driving.\n \n\n\nTrain an autopilot.\n \n\n\n\n\n\n\nHello World.\n\n\nDonkeycar is designed to make it easy to customize your car by adding or \nremoving parts. Here's a simple example of a car that just captures\nimages from the camera and saves them.\n\n\n\nimport donkey as dk\n\nV = dk.Vehicle()\n\n#add a camera\ncam = dk.parts.PiCamera()\nV.add(cam, outputs=['image'], threaded=True)\n\n#record the images\ntub = dk.parts.Tub(path='~/d2/gettings_started', \n                   inputs=['image'], \n                   types=['image_array'])\nV.add(tub, inputs=inputs)\n\n#start the drive loop\nV.start(max_loop_count=100)\n\n\n\n\n\n\nInstallation\n\n\nClone the master branch to get the lastest version. Use this if you plan \nto contribute code.. \n\n\ngit clone https://github.com/wroscoe/donkey donkeycar\npip install -e donkeycar\n\n\n\n\n\n\nWhy the name Donkey?\n\n\nThe ultimate goal of this project is to build something useful. Donkey's were\none of the first domesticated pack animals, they're notoriously stubborn, and \nthey are kid safe. Until the car can nagigate from one side of a city to the \nother, we'll hold off naming it after some celestial being.",
            "title": "Home"
        },
        {
            "location": "/#about-donkey",
            "text": "Donkey is a high level self driving library written in Python and capable of \ncontrolling ackerman or differential drive vehicles. It was developed with a \nfocus on enabling fast experimentation and easy contribution.",
            "title": "About Donkey"
        },
        {
            "location": "/#build-your-own-donkey2",
            "text": "Donkey2 is the standard car that most people start with. The parts cost $200\nand take 2 hours to assemple. Here are the main steps to build your own car:    Build a car. .  Install the software.  Calibrate your car.  Start driving.    Train an autopilot.",
            "title": "Build your own Donkey2"
        },
        {
            "location": "/#hello-world",
            "text": "Donkeycar is designed to make it easy to customize your car by adding or \nremoving parts. Here's a simple example of a car that just captures\nimages from the camera and saves them.  \nimport donkey as dk\n\nV = dk.Vehicle()\n\n#add a camera\ncam = dk.parts.PiCamera()\nV.add(cam, outputs=['image'], threaded=True)\n\n#record the images\ntub = dk.parts.Tub(path='~/d2/gettings_started', \n                   inputs=['image'], \n                   types=['image_array'])\nV.add(tub, inputs=inputs)\n\n#start the drive loop\nV.start(max_loop_count=100)",
            "title": "Hello World."
        },
        {
            "location": "/#installation",
            "text": "Clone the master branch to get the lastest version. Use this if you plan \nto contribute code..   git clone https://github.com/wroscoe/donkey donkeycar\npip install -e donkeycar",
            "title": "Installation"
        },
        {
            "location": "/#why-the-name-donkey",
            "text": "The ultimate goal of this project is to build something useful. Donkey's were\none of the first domesticated pack animals, they're notoriously stubborn, and \nthey are kid safe. Until the car can nagigate from one side of a city to the \nother, we'll hold off naming it after some celestial being.",
            "title": "Why the name Donkey?"
        },
        {
            "location": "/guide/build_hardware/",
            "text": "Instructions to build a Donkey2 Car\n\n\nThe standard hardware build instructions can be found in this \n\ngoogle doc\n.\n\n\nOnce you have the car built follow the \nsoftware instructions\n.",
            "title": "Build a car."
        },
        {
            "location": "/guide/build_hardware/#instructions-to-build-a-donkey2-car",
            "text": "The standard hardware build instructions can be found in this  google doc .  Once you have the car built follow the  software instructions .",
            "title": "Instructions to build a Donkey2 Car"
        },
        {
            "location": "/guide/install_software/",
            "text": "Install Software\n\n\nGet the Raspberry Pi working.\n\n\nBefore we can do anything we have to get our car's computer connected to the \ninternet. The fastest way is to use the disk image created for donkey cars. \n\n\nThe method for using a disk image to create a bootable SD card varies between\noperating systems. These instructions are for Ubuntu but you can see more \ninstructions \nhere\n.\n\n\n\n\nDownload \nzipped disk image\n (900MB). \n\n\nUnzip the disk image.\n\n\nPlug your SD card into your computer.\n\n\nOpen the \"Startup Disk Creator\" application.\n\n\nSelect your source disk image as the one you unzipped earlier.\n\n\nSelect your SD card as the disk to use. \n\n\nClick \"Make startup disk\".\n\n\n\n\nSince our pi doesn't have a monitor/keyboard/mouse let's setup the pi's wifi\nnow.\n\n\n\n\nstart a text editor with root privelidges ie. \nsudo gedit\n\n\nOpen the file \n/etc/wpa_supplicant/wpa_supplicant.conf\n in the text editor\nand edit the wifi credentials to your wifi settings.\n\n\n\n\nNow you're SD card is ready. Eject it from your computer, put it in the Pi \nand plug in the Pi. \n\n\nConnecting to the Pi\n\n\nIf you followed the above instructions to add wifi access you're Pi should\nnow be connected to your wifi network. Now you need to find it's IP address\nso you can connect to it via SSH. \n\n\n\n\nNote: If you didn't setup the wifi earlier you'll need to attach a monitor,\nkeyboard and mouse so you can log setup the wifi via the command line. \n\n\n\n\nThe easiest way (on Ubuntu) is to use the \nfindcar\n donkey command. Regardless \nyou will wand donkeycar installed on your computer for training so lets install\ndonkeycar now. \n\n\nvirtualenv env -p python3\nsource env/bin/activate\npip install donkeycar\ndonkeycar findcar\n\n\n\n\nThis will show your ip address, promt for your password, and then search \nfor your cars ip address. \n\n\n\n\nIf your car's ip address is not shown then:\n1. find another way to scan your local network for your raspbery pi \n2. connect a monitor to your pi to connect to the the same wifi as your computer. \n\n\n\n\nAssuming that you did find your pi on the network. You can now connect to it\nremotely via ssh. \n\n\nssh pi@<your_pi_ip_address>\n\n\n\n\nThe default username is 'pi' and the password is 'raspberry'\n\n\nCreate your car app\n\n\ndonkey createcar --path ~/d2",
            "title": "Install the software."
        },
        {
            "location": "/guide/install_software/#install-software",
            "text": "",
            "title": "Install Software"
        },
        {
            "location": "/guide/install_software/#get-the-raspberry-pi-working",
            "text": "Before we can do anything we have to get our car's computer connected to the \ninternet. The fastest way is to use the disk image created for donkey cars.   The method for using a disk image to create a bootable SD card varies between\noperating systems. These instructions are for Ubuntu but you can see more \ninstructions  here .   Download  zipped disk image  (900MB).   Unzip the disk image.  Plug your SD card into your computer.  Open the \"Startup Disk Creator\" application.  Select your source disk image as the one you unzipped earlier.  Select your SD card as the disk to use.   Click \"Make startup disk\".   Since our pi doesn't have a monitor/keyboard/mouse let's setup the pi's wifi\nnow.   start a text editor with root privelidges ie.  sudo gedit  Open the file  /etc/wpa_supplicant/wpa_supplicant.conf  in the text editor\nand edit the wifi credentials to your wifi settings.   Now you're SD card is ready. Eject it from your computer, put it in the Pi \nand plug in the Pi.",
            "title": "Get the Raspberry Pi working."
        },
        {
            "location": "/guide/install_software/#connecting-to-the-pi",
            "text": "If you followed the above instructions to add wifi access you're Pi should\nnow be connected to your wifi network. Now you need to find it's IP address\nso you can connect to it via SSH.    Note: If you didn't setup the wifi earlier you'll need to attach a monitor,\nkeyboard and mouse so you can log setup the wifi via the command line.    The easiest way (on Ubuntu) is to use the  findcar  donkey command. Regardless \nyou will wand donkeycar installed on your computer for training so lets install\ndonkeycar now.   virtualenv env -p python3\nsource env/bin/activate\npip install donkeycar\ndonkeycar findcar  This will show your ip address, promt for your password, and then search \nfor your cars ip address.    If your car's ip address is not shown then:\n1. find another way to scan your local network for your raspbery pi \n2. connect a monitor to your pi to connect to the the same wifi as your computer.    Assuming that you did find your pi on the network. You can now connect to it\nremotely via ssh.   ssh pi@<your_pi_ip_address>  The default username is 'pi' and the password is 'raspberry'",
            "title": "Connecting to the Pi"
        },
        {
            "location": "/guide/install_software/#create-your-car-app",
            "text": "donkey createcar --path ~/d2",
            "title": "Create your car app"
        },
        {
            "location": "/guide/get_driving/",
            "text": "Drive your car.\n\n\nAfter you've calibrated your car you can start driving it. \n\n\nStart your car.\n\n\n\n\n Put your car in a safe place where the wheels are off the ground \n This\nis the step were the car can take off. \n\n\n\n\nOpen your car's folder and start our car. \n\n\ncd ~/d2\npython manage.py drive\n\n\n\n\nThis script will start the drive loop in your car which includes a part that \nis a webserver for you to control your car. You can now controll your car\nfrom a web browser at the url: \n<your car's ip's address>:8887\n\n\n\n\nDriving\n\n\nOn your phone you can now press start to set your phones current tilt to be\nzero throttle and steering. Now tilting your phone forward will increase throttle\nand tilting it side to side will turn the steering. \n\n\nFeatures\n\n\n\n\nRecording - Press record data to start recording images, steering angels and throttle values. \n\n\nThrottle mode - Option to set the throttle as constant. This is used in \nraces if you have a pilot that will steer but doesn't control throttle. \n\n\nPilot mode - Choose if the pilot should control the angle and/or throttle.\n\n\nMax throttle - Select the maximum throttle.\n\n\n\n\nKeyboard shortcuts\n\n\n\n\nspace\n : stop car and stop recording\n\n\nr\n : toggle recording\n\n\ni\n : increase throttle\n\n\nk\n : decrease throttle\n\n\nj\n : turn left \n\n\nl\n : turn right",
            "title": "Get driving."
        },
        {
            "location": "/guide/get_driving/#drive-your-car",
            "text": "After you've calibrated your car you can start driving it.",
            "title": "Drive your car."
        },
        {
            "location": "/guide/get_driving/#start-your-car",
            "text": "Put your car in a safe place where the wheels are off the ground   This\nis the step were the car can take off.    Open your car's folder and start our car.   cd ~/d2\npython manage.py drive  This script will start the drive loop in your car which includes a part that \nis a webserver for you to control your car. You can now controll your car\nfrom a web browser at the url:  <your car's ip's address>:8887",
            "title": "Start your car."
        },
        {
            "location": "/guide/get_driving/#driving",
            "text": "On your phone you can now press start to set your phones current tilt to be\nzero throttle and steering. Now tilting your phone forward will increase throttle\nand tilting it side to side will turn the steering.",
            "title": "Driving"
        },
        {
            "location": "/guide/get_driving/#features",
            "text": "Recording - Press record data to start recording images, steering angels and throttle values.   Throttle mode - Option to set the throttle as constant. This is used in \nraces if you have a pilot that will steer but doesn't control throttle.   Pilot mode - Choose if the pilot should control the angle and/or throttle.  Max throttle - Select the maximum throttle.",
            "title": "Features"
        },
        {
            "location": "/guide/get_driving/#keyboard-shortcuts",
            "text": "space  : stop car and stop recording  r  : toggle recording  i  : increase throttle  k  : decrease throttle  j  : turn left   l  : turn right",
            "title": "Keyboard shortcuts"
        },
        {
            "location": "/guide/calibrate/",
            "text": "Calibrate your Car\n\n\nThe point of calibrating your car is to make it drive consitently with\nother vehicles. These instructions \n\n\nHow to adjust your car's settings.\n\n\nAll of the car's settings are in the \nmanage.py\n script generated when \nyou ran the \ndonkey createcar --path ~/d2\n command. You can edit\nthis file on your car by running:\n\n\nnano ~/d2/manage.py\n\n\n\n\nOur goal is to edit these settings so your car will drive like every\nother calibrated Donkey2. This way you'll be able to share pilots and \ndatasets between each car. \n\n\nSteering Calibration\n\n\n\n\nMake sure your car is off the ground to prevent a runaway situation.\n\n\n\n\n\n\nTurn on your car.\n\n\nFind the servo cable on your car and see what channel it's plugged into the\nPCA board. It should be 1 or 0.\n\n\nRun \ndonkey calibrate --channel <your_steering_channel>\n\n\nEnter \n360' and you should see the wheels on your car move slightly. If not \nenter\n400\nor\n300`.\n\n\nNext enter values +/- 10 from your starting value to find the PWM setting\nthat makes your car turn all the way left and all the way right. Remember \nthese values. \n\n\nEnter these values in your \nmanage.py\n script as inputs into your \nsteering_controller part as the \nleft_pulse\n and \nright_pulse\n. \n\n\n\n\nThrottle Calibration\n\n\n\n\nFind the cable coming from your ESC and see what channel it goes into the\nPCA board. This is your throttle channel.\n\n\nrun \ndonkey calibrate --channel <your_throttle_channel>\n\n\nEnter \n370\n when prompted for a PWM value.\n\n\nYou should hear your ESC beep indicating that it's calibrated. \n\n\nEnter \n400\n and you should see yoru cars wheels start to go forward. If not,\nits likely that this is reverse, try entering \n330\n instead.\n\n\nKeep trying different values until you've found a reasonable max speed and\nremember this PWM value.\n\n\n\n\nReverse on RC cars is a little trickey because the ESC needs to recieve a\nreverse pulse, zero pulse, reverse pulse to start to go backwards. To calibrate\na reverse PWM setting...\n\n\n\n\nUse the same technique as above set the PWM setting to your zero throttle. \n\n\nEnter the reverse value, then the zero throttle value, then the reverse \nvalue again. \n\n\nEnter values +/- 10 of the reverse value to find a reasonable reverse speed.\nRember this reverse PWM value. \n\n\n\n\nNow open your \nmanage.py\n script and enter the PWM values for your car into\nthe throttle_controller part. \n\n \nmax_puse\n = PWM value for full throttle forward\n\n \nzero_pulse\n = PWM value for zero throttle\n* \nmin_pulse\n = PWM value at full reverse throttle\n\n\nFine tuning your calibration.\n\n\n\n\nNow that you have your care roughly calibrated you can try driving it to \nverify that it drives as expected. Here's how to fine tune your car's calibration. \n\n\n\n\nStart your car by running \npython manage.py drive\n.\n\n\nGo to \n<your_cars_ip_address>:8887\n in a browser. \n\n\nPress \nj\n until the cars steering is all the way right. \n\n\nPress \ni\n a couple times to get the car to go forward.\n\n\nMeasure the diameter of the turn and record on it in a spreadsheet. \n\n\nRepeat this measurement for different steering values for turning each \ndirection. \n\n\nChart these so you can see if your car turns the same in each direction. \n\n\n\n\nCorrections\n\n If your car turns the same amount at an 80% turn and a 100% turn change the\nPWM setting for that turn direction to be the PWM value at 80%. \n\n If your car is biased to turn on direction, change the PWM values of your turns\nin the opisite direction of the bias.\n\n\nAfter you've fine tuned your car the steering chart should look something like\nthis.",
            "title": "Calibrate steering and throttle."
        },
        {
            "location": "/guide/calibrate/#calibrate-your-car",
            "text": "The point of calibrating your car is to make it drive consitently with\nother vehicles. These instructions",
            "title": "Calibrate your Car"
        },
        {
            "location": "/guide/calibrate/#how-to-adjust-your-cars-settings",
            "text": "All of the car's settings are in the  manage.py  script generated when \nyou ran the  donkey createcar --path ~/d2  command. You can edit\nthis file on your car by running:  nano ~/d2/manage.py  Our goal is to edit these settings so your car will drive like every\nother calibrated Donkey2. This way you'll be able to share pilots and \ndatasets between each car.",
            "title": "How to adjust your car's settings."
        },
        {
            "location": "/guide/calibrate/#steering-calibration",
            "text": "Make sure your car is off the ground to prevent a runaway situation.    Turn on your car.  Find the servo cable on your car and see what channel it's plugged into the\nPCA board. It should be 1 or 0.  Run  donkey calibrate --channel <your_steering_channel>  Enter  360' and you should see the wheels on your car move slightly. If not \nenter 400 or 300`.  Next enter values +/- 10 from your starting value to find the PWM setting\nthat makes your car turn all the way left and all the way right. Remember \nthese values.   Enter these values in your  manage.py  script as inputs into your \nsteering_controller part as the  left_pulse  and  right_pulse .",
            "title": "Steering Calibration"
        },
        {
            "location": "/guide/calibrate/#throttle-calibration",
            "text": "Find the cable coming from your ESC and see what channel it goes into the\nPCA board. This is your throttle channel.  run  donkey calibrate --channel <your_throttle_channel>  Enter  370  when prompted for a PWM value.  You should hear your ESC beep indicating that it's calibrated.   Enter  400  and you should see yoru cars wheels start to go forward. If not,\nits likely that this is reverse, try entering  330  instead.  Keep trying different values until you've found a reasonable max speed and\nremember this PWM value.   Reverse on RC cars is a little trickey because the ESC needs to recieve a\nreverse pulse, zero pulse, reverse pulse to start to go backwards. To calibrate\na reverse PWM setting...   Use the same technique as above set the PWM setting to your zero throttle.   Enter the reverse value, then the zero throttle value, then the reverse \nvalue again.   Enter values +/- 10 of the reverse value to find a reasonable reverse speed.\nRember this reverse PWM value.    Now open your  manage.py  script and enter the PWM values for your car into\nthe throttle_controller part.    max_puse  = PWM value for full throttle forward   zero_pulse  = PWM value for zero throttle\n*  min_pulse  = PWM value at full reverse throttle",
            "title": "Throttle Calibration"
        },
        {
            "location": "/guide/calibrate/#fine-tuning-your-calibration",
            "text": "Now that you have your care roughly calibrated you can try driving it to \nverify that it drives as expected. Here's how to fine tune your car's calibration.    Start your car by running  python manage.py drive .  Go to  <your_cars_ip_address>:8887  in a browser.   Press  j  until the cars steering is all the way right.   Press  i  a couple times to get the car to go forward.  Measure the diameter of the turn and record on it in a spreadsheet.   Repeat this measurement for different steering values for turning each \ndirection.   Chart these so you can see if your car turns the same in each direction.    Corrections  If your car turns the same amount at an 80% turn and a 100% turn change the\nPWM setting for that turn direction to be the PWM value at 80%.   If your car is biased to turn on direction, change the PWM values of your turns\nin the opisite direction of the bias.  After you've fine tuned your car the steering chart should look something like\nthis.",
            "title": "Fine tuning your calibration."
        },
        {
            "location": "/guide/train_autopilot/",
            "text": "Train an autopilot with Keras\n\n\nNow that you're able to drive your car reliably you can use Keras to train a\nneural network to drive like you. Here are the steps.\n\n\nCollect Data\n\n\nMake sure you collect good data. \n\n\n\n\nPractice driving around the track a couple times without recording data.\n\n\nWhen you're confident you can drive 10 laps without mistake press \nStart Recording\n\n\nIf you crash or run off the track press Stop Car imediatly to stop recording. \nA little bad data won't affect your autopilot. \n\n\nAfter you've collected 10-20 laps of good data (5-20k images) you can stop \nyour car with \nCtrl-c\n in the ssh session for your car.\n\n\nThe data you've collected is in the data folder in the most recent tub folder.\n\n\n\n\nTransfer data from your car to you computer.\n\n\nSince the Raspberry Pi is not very powerful we need to transfer the data\nto our computer to train. \n\n\nIn a new terminal session on your comptuer use rsync to copy your cars \nfolder. \n\n\nrsync pi@<your_pi_ip_address>:~/d2/data  ~/d2/data\n\n\n\n\nTrain a model.\n\n\n\n\nIn the same terminal you can now run the training script on the latest tub.\n\n\n\n\n python ~/d2/manage.py train --model mypilot\n\n\n\n\n\n\nNow you can use rsync again to move your pilot back to your car. \n\n\n\n\nrsync ~/d2/models pi@<your_ip_address>:~/d2/models\n\n\n\n\n\n\nNow you can start your car again and pass it your model to drive.\n```\npython ~/d2/manage.py drive --model mypilot",
            "title": "Train an autopilot."
        },
        {
            "location": "/guide/train_autopilot/#train-an-autopilot-with-keras",
            "text": "Now that you're able to drive your car reliably you can use Keras to train a\nneural network to drive like you. Here are the steps.",
            "title": "Train an autopilot with Keras"
        },
        {
            "location": "/guide/train_autopilot/#collect-data",
            "text": "Make sure you collect good data.    Practice driving around the track a couple times without recording data.  When you're confident you can drive 10 laps without mistake press  Start Recording  If you crash or run off the track press Stop Car imediatly to stop recording. \nA little bad data won't affect your autopilot.   After you've collected 10-20 laps of good data (5-20k images) you can stop \nyour car with  Ctrl-c  in the ssh session for your car.  The data you've collected is in the data folder in the most recent tub folder.",
            "title": "Collect Data"
        },
        {
            "location": "/guide/train_autopilot/#transfer-data-from-your-car-to-you-computer",
            "text": "Since the Raspberry Pi is not very powerful we need to transfer the data\nto our computer to train.   In a new terminal session on your comptuer use rsync to copy your cars \nfolder.   rsync pi@<your_pi_ip_address>:~/d2/data  ~/d2/data",
            "title": "Transfer data from your car to you computer."
        },
        {
            "location": "/guide/train_autopilot/#train-a-model",
            "text": "In the same terminal you can now run the training script on the latest tub.    python ~/d2/manage.py train --model mypilot   Now you can use rsync again to move your pilot back to your car.    rsync ~/d2/models pi@<your_ip_address>:~/d2/models   Now you can start your car again and pass it your model to drive.\n```\npython ~/d2/manage.py drive --model mypilot",
            "title": "Train a model."
        },
        {
            "location": "/parts/about/",
            "text": "What is a Part\n\n\nA part python class that wraps a functional component of a vehicle. \nThese include: \n\n Sensors - Cameras, Lidar, Odometers, GPS ...\n\n Actuators - Motor Controllers\n\n Pilots - Lane Detectors, Behavioral Cloning models, ...\n\n Controllers - Web based or bluetooth.\n* Stores - Tub, or a way to save data. \n\n\nHere is an example how to use the PiCamera part to publish an image in the\n'cam/img' channel on every drive loop.\n\n\nV = dk.Vehicle()\n\n#initialize the camera part\ncam = dk.parts.PiCamera()\n\n#add the part to the vehicle.\nV.add(cam, outputs=['cam/img'])\n\nV.start()\n\n\n\n\nAnatomy of a Part\n\n\nAll parts share a common structure so that they can all be run by the vehicles\ndrive loop. Here is an example of a part that will accept a number, multiply \nit by a random number and return the result.\n\n\nimport random \n\nclass RandPercent:\n    def run(self, x):\n        return x * random.random()\n\n\n\n\nNow to add this to a vehicle:\n\n\nV = dk.Vehicle()\n\n#initialize the channel value\nV.mem['const'] = 4\n\n#add the part to read and write to the same channel.\nV.add(RandPercent, inputs=['const'], outputs=['cost'])\n\nV.start(max_loops=5)\n\n\n\n\nThreaded Parts\n\n\nFor a vehicle to perform well the drive loop must execute 10-30 times per\nsecond so slow parts should be threaded to avoid holding up the drive loop.\n\n\nA threaded part needs to define the function that runs in the separate thread\nand the function to call that will return the most recent values quickly. \n\n\nHere's an example how to make the RandPercent part threaded if the run\nfunction too a second to complete. \n\n\nimport random \nimport time\n\nclass RandPercent:\n    self.in = 0.\n    self.out = 0.\n    def run(self, x):\n        return x * random.random()\n        time.sleep(1)\n\n    def update(self):\n        #the funtion run in it's own thread\n        while True:\n            self.out = self.run(self.in)\n\n    def run_threaded(self, x):\n        self.in = x\n        return self.out\n\n\n\n\n\n\n\npart.run\n : function used to run the part\n\n\npart.run_threaded\n : drive loop function run if part is threaded.\n\n\npart.update\n : threaded function  \n\n\npart.shutdown",
            "title": "About"
        },
        {
            "location": "/parts/about/#what-is-a-part",
            "text": "A part python class that wraps a functional component of a vehicle. \nThese include:   Sensors - Cameras, Lidar, Odometers, GPS ...  Actuators - Motor Controllers  Pilots - Lane Detectors, Behavioral Cloning models, ...  Controllers - Web based or bluetooth.\n* Stores - Tub, or a way to save data.   Here is an example how to use the PiCamera part to publish an image in the\n'cam/img' channel on every drive loop.  V = dk.Vehicle()\n\n#initialize the camera part\ncam = dk.parts.PiCamera()\n\n#add the part to the vehicle.\nV.add(cam, outputs=['cam/img'])\n\nV.start()",
            "title": "What is a Part"
        },
        {
            "location": "/parts/about/#anatomy-of-a-part",
            "text": "All parts share a common structure so that they can all be run by the vehicles\ndrive loop. Here is an example of a part that will accept a number, multiply \nit by a random number and return the result.  import random \n\nclass RandPercent:\n    def run(self, x):\n        return x * random.random()  Now to add this to a vehicle:  V = dk.Vehicle()\n\n#initialize the channel value\nV.mem['const'] = 4\n\n#add the part to read and write to the same channel.\nV.add(RandPercent, inputs=['const'], outputs=['cost'])\n\nV.start(max_loops=5)",
            "title": "Anatomy of a Part"
        },
        {
            "location": "/parts/about/#threaded-parts",
            "text": "For a vehicle to perform well the drive loop must execute 10-30 times per\nsecond so slow parts should be threaded to avoid holding up the drive loop.  A threaded part needs to define the function that runs in the separate thread\nand the function to call that will return the most recent values quickly.   Here's an example how to make the RandPercent part threaded if the run\nfunction too a second to complete.   import random \nimport time\n\nclass RandPercent:\n    self.in = 0.\n    self.out = 0.\n    def run(self, x):\n        return x * random.random()\n        time.sleep(1)\n\n    def update(self):\n        #the funtion run in it's own thread\n        while True:\n            self.out = self.run(self.in)\n\n    def run_threaded(self, x):\n        self.in = x\n        return self.out   part.run  : function used to run the part  part.run_threaded  : drive loop function run if part is threaded.  part.update  : threaded function    part.shutdown",
            "title": "Threaded Parts"
        },
        {
            "location": "/parts/actuators/",
            "text": "",
            "title": "Actuators"
        },
        {
            "location": "/parts/stores/",
            "text": "Stores\n\n\nStores are parts that record and replay vehicle data produced by other parts. \n\n\nTub\n\n\nThis is the standard donkey data store and it is modeled after the ROSBAG.\n\n\n\n\nTODO: The structure of the Tub part is not ideal and should be changed.\n\n\n\n\ntypes should not need to be specified and could be inspected and saved \non the first loop.\n\n\n\n\n\n\nExample creation \n\n\nimport donkey as dk\n\nT = dk.parts.Tub(path, inputs, types)\n\n\n\n\n\nAccepted Types\n\n\n\n\nfloat\n - saved as record\n\n\nint\n - saved as record",
            "title": "Stores"
        },
        {
            "location": "/parts/stores/#stores",
            "text": "Stores are parts that record and replay vehicle data produced by other parts.",
            "title": "Stores"
        },
        {
            "location": "/parts/stores/#tub",
            "text": "This is the standard donkey data store and it is modeled after the ROSBAG.   TODO: The structure of the Tub part is not ideal and should be changed.   types should not need to be specified and could be inspected and saved \non the first loop.    Example creation   import donkey as dk\n\nT = dk.parts.Tub(path, inputs, types)",
            "title": "Tub"
        },
        {
            "location": "/parts/stores/#accepted-types",
            "text": "float  - saved as record  int  - saved as record",
            "title": "Accepted Types"
        },
        {
            "location": "/contribute/",
            "text": "Contribute to Donkey\n\n\nDonkey is an opensource project to help accelerate the developement of \nself driving autos. \n\n\nGuiding Developement Principles\n\n\n\n\nModularity\n: A self driving system is composed of standalone, \nindependently configurable components that can be combined to make a car.\n\n\nMinimalism\n: Each component should be kept short (<100 lines of code). \nEach peice of code should be transparent apon first reading. No black magic, \nit slows the speed of innovation. \n\n\nExtensiblity\n: New components should be simple to create by following a \ntemplate. \n\n\nPython\n: Keep it simple. \n\n\n\n\nThese guidelines are nearly copied from \nKeras\n because they are so good\n \n\n\nAdd a part.\n\n\nAre you a hardware specialist that can write a donkey part wrapper for a\nGPS unit or a data scientist that can write an recursive neural net autopilot?\nIf so please write a part so other people driving donkeys can use the part.\n\n\nFix or report a bug.\n\n\nIf you find a problem with the code and you know how to fix it then please\nclone the repo, make your fix, and submit your pull request.\n\n\nReply to issues.\n\n\nHelping close or triage the issues is a good way to help.\n\n\nNeed Inspiration?\n\n\nSearch the code or docs for \nTODO\n to find places where you might be able \nto find a better solution. \n\n\nImprove the documentation.\n\n\nYou can fix grammar or provide clarity by clicking the the \nEdit on GitHub\n \nlink in the top right corner.",
            "title": "Contribute"
        },
        {
            "location": "/contribute/#contribute-to-donkey",
            "text": "Donkey is an opensource project to help accelerate the developement of \nself driving autos.",
            "title": "Contribute to Donkey"
        },
        {
            "location": "/contribute/#guiding-developement-principles",
            "text": "Modularity : A self driving system is composed of standalone, \nindependently configurable components that can be combined to make a car.  Minimalism : Each component should be kept short (<100 lines of code). \nEach peice of code should be transparent apon first reading. No black magic, \nit slows the speed of innovation.   Extensiblity : New components should be simple to create by following a \ntemplate.   Python : Keep it simple.    These guidelines are nearly copied from  Keras  because they are so good",
            "title": "Guiding Developement Principles"
        },
        {
            "location": "/contribute/#add-a-part",
            "text": "Are you a hardware specialist that can write a donkey part wrapper for a\nGPS unit or a data scientist that can write an recursive neural net autopilot?\nIf so please write a part so other people driving donkeys can use the part.",
            "title": "Add a part."
        },
        {
            "location": "/contribute/#fix-or-report-a-bug",
            "text": "If you find a problem with the code and you know how to fix it then please\nclone the repo, make your fix, and submit your pull request.",
            "title": "Fix or report a bug."
        },
        {
            "location": "/contribute/#reply-to-issues",
            "text": "Helping close or triage the issues is a good way to help.",
            "title": "Reply to issues."
        },
        {
            "location": "/contribute/#need-inspiration",
            "text": "Search the code or docs for  TODO  to find places where you might be able \nto find a better solution.",
            "title": "Need Inspiration?"
        },
        {
            "location": "/contribute/#improve-the-documentation",
            "text": "You can fix grammar or provide clarity by clicking the the  Edit on GitHub  \nlink in the top right corner.",
            "title": "Improve the documentation."
        },
        {
            "location": "/tests/",
            "text": "Tests\n\n\nThere is a limited test suite to ensure that the your changes to the code\ndon't break something unintended. \n\n\nRun all the tests\n\n\npython -m unittest\n\n\nOrganization\n\n\nThe test code is in \ntests\n foders in the same folder as the code. This is to\nhelp keep the test code linked to the code its self. If you change the code, \nchange the tests. :)\n\n\n\n\nTODO: Skip tests that require specific hardware.",
            "title": "Tests"
        },
        {
            "location": "/tests/#tests",
            "text": "There is a limited test suite to ensure that the your changes to the code\ndon't break something unintended.",
            "title": "Tests"
        },
        {
            "location": "/tests/#run-all-the-tests",
            "text": "python -m unittest",
            "title": "Run all the tests"
        },
        {
            "location": "/tests/#organization",
            "text": "The test code is in  tests  foders in the same folder as the code. This is to\nhelp keep the test code linked to the code its self. If you change the code, \nchange the tests. :)   TODO: Skip tests that require specific hardware.",
            "title": "Organization"
        },
        {
            "location": "/faq/",
            "text": "How do I create my own Raspberry Pi Disk?\n\n\nIf you don't want to use the disk image for the Raspberry Pi you can \ninstall the packages like this.\n\n\n\n\nSetup OS on Raspberry Pi\nFollow \nthese instructions\n\nto install the Raspbian Jessie operating system using the NOOBS method \non your SD card.\nP\n\n\nut the SD card into your Raspberry Pi.\n\n\nPower up your Raspberry Pi using the USB cable.\n\n\nConnect to a wifi internet connection. \n\n\n\n\nInstall Basic Libraries\n\n\nSince the Raspberry Pi is not as fast as larger computers, it can take a long time to install python packages (ie. numpy & PIL) using pip. Luckily Adafruit has precompiled these libraries into packages that can be installed via \napt-get\n.\n\n\n\n\nOpen a terminal (Ctrl-Alt-t) and upgrade your system packages.\n\n\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\n\n\nInstall necessary libraries \n\n\n\n\nsudo apt-get install xsel xclip libxml2-dev libxslt-dev libzmq-dev libspatialindex-dev virtualenv\n\n\n\n\n\n\nPandas & Jupyter Requirements\n\n\n\n\nsudo apt-get install python3-lxml python3-h5py python3-numexpr python3-dateutil python3-tz python3-bs4 python3-xlrd python3-tables python3-sqlalchemy python3-xlsxwriter python3-httplib2 python3-zmq \n\n\n\n\n\n\nScientific Python\n\n\n\n\nsudo apt-get install python3-numpy python3-matplotlib python3-scipy python3-pandas",
            "title": "FAQ"
        },
        {
            "location": "/faq/#how-do-i-create-my-own-raspberry-pi-disk",
            "text": "If you don't want to use the disk image for the Raspberry Pi you can \ninstall the packages like this.   Setup OS on Raspberry Pi\nFollow  these instructions \nto install the Raspbian Jessie operating system using the NOOBS method \non your SD card.\nP  ut the SD card into your Raspberry Pi.  Power up your Raspberry Pi using the USB cable.  Connect to a wifi internet connection.",
            "title": "How do I create my own Raspberry Pi Disk?"
        },
        {
            "location": "/faq/#install-basic-libraries",
            "text": "Since the Raspberry Pi is not as fast as larger computers, it can take a long time to install python packages (ie. numpy & PIL) using pip. Luckily Adafruit has precompiled these libraries into packages that can be installed via  apt-get .   Open a terminal (Ctrl-Alt-t) and upgrade your system packages.   sudo apt-get update\nsudo apt-get upgrade   Install necessary libraries    sudo apt-get install xsel xclip libxml2-dev libxslt-dev libzmq-dev libspatialindex-dev virtualenv   Pandas & Jupyter Requirements   sudo apt-get install python3-lxml python3-h5py python3-numexpr python3-dateutil python3-tz python3-bs4 python3-xlrd python3-tables python3-sqlalchemy python3-xlsxwriter python3-httplib2 python3-zmq    Scientific Python   sudo apt-get install python3-numpy python3-matplotlib python3-scipy python3-pandas",
            "title": "Install Basic Libraries"
        }
    ]
}